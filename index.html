<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MakeCode Arcade Video + Audio + Image Converter</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --arcade-black: #0d0d0d;
            --arcade-dark: #1a1a2e;
            --arcade-purple: #5c406c;
            --arcade-pink: #ff93c4;
            --arcade-cyan: #87f2ff;
            --arcade-yellow: #fff609;
            --arcade-green: #78dc52;
            --arcade-orange: #ff8135;
            --arcade-red: #ff2121;
            --panel-bg: #16213e;
            --panel-border: #0f3460;
            --text-dim: #a4839f;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--arcade-black);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            padding: 20px 0 30px;
        }

        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 2.5vw, 22px);
            color: var(--arcade-cyan);
            text-shadow: 
                0 0 10px var(--arcade-cyan),
                0 0 20px var(--arcade-cyan),
                3px 3px 0 var(--arcade-purple);
            letter-spacing: 1px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px var(--arcade-cyan), 0 0 20px var(--arcade-cyan), 3px 3px 0 var(--arcade-purple); }
            to { text-shadow: 0 0 20px var(--arcade-cyan), 0 0 40px var(--arcade-cyan), 0 0 60px var(--arcade-cyan), 3px 3px 0 var(--arcade-purple); }
        }

        .subtitle {
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            color: var(--arcade-pink);
            margin-top: 12px;
            letter-spacing: 1px;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .mode-btn {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            padding: 12px 24px;
            background: var(--arcade-dark);
            border: 3px solid var(--panel-border);
            border-radius: 8px;
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mode-btn:hover {
            border-color: var(--arcade-purple);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, var(--arcade-purple) 0%, var(--arcade-dark) 100%);
            border-color: var(--arcade-pink);
            color: var(--arcade-pink);
            box-shadow: 0 0 15px rgba(255, 147, 196, 0.3);
        }

        .mode-content {
            display: none;
        }

        .mode-content.active {
            display: block;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 1100px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: linear-gradient(135deg, var(--panel-bg) 0%, var(--arcade-dark) 100%);
            border: 3px solid var(--panel-border);
            border-radius: 12px;
            padding: 20px;
            position: relative;
            box-shadow: 0 0 20px rgba(135, 242, 255, 0.1);
        }

        .panel::before {
            content: '';
            position: absolute;
            top: -3px;
            left: 20px;
            right: 20px;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--arcade-cyan), transparent);
        }

        .panel.audio-panel::before {
            background: linear-gradient(90deg, transparent, var(--arcade-orange), transparent);
        }

        .panel.image-panel::before {
            background: linear-gradient(90deg, transparent, var(--arcade-pink), transparent);
        }

        .panel-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--arcade-yellow);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title::before {
            content: '‚ñ∏';
            color: var(--arcade-green);
        }

        .panel-title.audio::before {
            content: '‚ô™';
            color: var(--arcade-orange);
        }

        .panel-title.image::before {
            content: 'üñº';
        }

        /* Upload Zone */
        .upload-zone {
            border: 3px dashed var(--arcade-purple);
            border-radius: 8px;
            padding: 30px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(92, 64, 108, 0.1);
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--arcade-pink);
            background: rgba(255, 147, 196, 0.1);
            box-shadow: 0 0 30px rgba(255, 147, 196, 0.2);
        }

        .upload-icon {
            font-size: 40px;
            margin-bottom: 10px;
            display: block;
        }

        .upload-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            color: var(--arcade-pink);
            margin-bottom: 6px;
        }

        .upload-hint {
            font-size: 11px;
            color: var(--text-dim);
        }

        #videoInput, #imageInput {
            display: none;
        }

        /* Video Preview */
        .preview-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
        }

        #videoPreview {
            max-width: 100%;
            max-height: 100%;
            display: none;
        }

        .preview-placeholder {
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            color: var(--text-dim);
            text-align: center;
        }

        /* Image Preview */
        .image-preview-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            min-height: 200px;
        }

        .image-preview-container img {
            max-width: 100%;
            max-height: 400px;
            image-rendering: pixelated;
        }

        .image-preview-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .image-preview-box {
            text-align: center;
        }

        .image-preview-box label {
            display: block;
            margin-bottom: 8px;
            font-size: 9px;
        }

        .image-preview-box canvas {
            border: 2px solid var(--panel-border);
            border-radius: 4px;
            image-rendering: pixelated;
        }

        /* Time Range Selector */
        .time-range-container {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .time-range-bar {
            height: 12px;
            background: var(--arcade-dark);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            border: 2px solid var(--panel-border);
        }

        .time-range-selected {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, var(--arcade-green), var(--arcade-cyan));
            border-radius: 4px;
            transition: left 0.2s, width 0.2s;
        }

        .time-range-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 9px;
            color: var(--text-dim);
        }

        .time-range-labels #timeRangeInfo {
            color: var(--arcade-cyan);
            font-weight: 600;
        }

        /* Controls */
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 10px;
            color: var(--arcade-cyan);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        label.audio-label {
            color: var(--arcade-orange);
        }

        label.image-label {
            color: var(--arcade-pink);
        }

        input[type="number"],
        select {
            background: var(--arcade-black);
            border: 2px solid var(--panel-border);
            border-radius: 6px;
            padding: 8px 10px;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: var(--arcade-cyan);
            box-shadow: 0 0 10px rgba(135, 242, 255, 0.3);
        }

        /* Checkbox */
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--arcade-black);
            border: 2px solid var(--panel-border);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .checkbox-group input[type="checkbox"]:checked {
            background: var(--arcade-green);
            border-color: var(--arcade-green);
        }

        .checkbox-group input[type="checkbox"]:checked::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--arcade-black);
            font-weight: bold;
            font-size: 12px;
        }

        .checkbox-group label {
            cursor: pointer;
            text-transform: none;
            color: #fff;
            font-size: 11px;
        }

        /* Buttons */
        .btn {
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(180deg, var(--arcade-green) 0%, #5cb338 100%);
            color: var(--arcade-black);
            box-shadow: 0 4px 0 #3d7a24;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #3d7a24;
        }

        .btn-primary:disabled {
            background: #444;
            box-shadow: 0 4px 0 #333;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-secondary {
            background: linear-gradient(180deg, var(--arcade-purple) 0%, #4a3358 100%);
            color: #fff;
            box-shadow: 0 4px 0 #362440;
        }

        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-copy {
            background: linear-gradient(180deg, var(--arcade-cyan) 0%, #5bc4d4 100%);
            color: var(--arcade-black);
            box-shadow: 0 4px 0 #4a9da8;
        }

        .btn-copy:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-pink {
            background: linear-gradient(180deg, var(--arcade-pink) 0%, #d47a9f 100%);
            color: var(--arcade-black);
            box-shadow: 0 4px 0 #a65c7a;
        }

        .btn-pink:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #a65c7a;
        }

        .btn-pink:disabled {
            background: #444;
            box-shadow: 0 4px 0 #333;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .button-row {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        /* Progress */
        .progress-container {
            margin-top: 15px;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            height: 20px;
            background: var(--arcade-black);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid var(--panel-border);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--arcade-green), var(--arcade-cyan));
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-fill.audio {
            background: linear-gradient(90deg, var(--arcade-orange), var(--arcade-yellow));
        }

        .progress-text {
            text-align: center;
            margin-top: 8px;
            font-size: 11px;
            color: var(--arcade-cyan);
        }

        /* Palette */
        .palette-preview {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
            margin-top: 10px;
        }

        .palette-color {
            aspect-ratio: 1;
            border-radius: 3px;
            border: 2px solid var(--panel-border);
            position: relative;
        }

        .palette-color::after {
            content: attr(data-char);
            position: absolute;
            bottom: 1px;
            right: 3px;
            font-size: 8px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        /* Output */
        .output-container {
            margin-top: 15px;
        }

        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .output-stats {
            font-size: 10px;
            color: var(--text-dim);
        }

        .output-code {
            background: var(--arcade-black);
            border: 2px solid var(--panel-border);
            border-radius: 8px;
            padding: 12px;
            max-height: 250px;
            overflow: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            line-height: 1.4;
            color: var(--arcade-green);
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Frame Preview Grid */
        .frame-preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 4px;
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
        }

        .frame-thumb {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 2px;
            image-rendering: pixelated;
            border: 1px solid var(--panel-border);
        }

        /* Spectrogram */
        .spectrogram-container {
            background: var(--arcade-black);
            border: 2px solid var(--panel-border);
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            min-height: 100px;
        }

        #spectrogramCanvas {
            width: 100%;
            height: 100px;
            display: block;
        }

        .freq-buckets {
            display: flex;
            gap: 2px;
            align-items: flex-end;
            height: 52px;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            margin-top: 8px;
        }

        .freq-bucket {
            flex: 1;
            background: linear-gradient(to top, var(--arcade-orange), var(--arcade-yellow));
            border-radius: 2px 2px 0 0;
            min-height: 2px;
            transition: height 0.1s ease;
        }

        /* Status */
        .status-message {
            padding: 10px 12px;
            border-radius: 6px;
            margin-top: 12px;
            font-size: 11px;
            display: none;
        }

        .status-message.success {
            display: block;
            background: rgba(120, 220, 82, 0.2);
            border: 1px solid var(--arcade-green);
            color: var(--arcade-green);
        }

        .status-message.error {
            display: block;
            background: rgba(255, 33, 33, 0.2);
            border: 1px solid var(--arcade-red);
            color: var(--arcade-red);
        }

        .status-message.info {
            display: block;
            background: rgba(135, 242, 255, 0.2);
            border: 1px solid var(--arcade-cyan);
            color: var(--arcade-cyan);
        }

        /* Tabs */
        .output-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .tab-btn {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            padding: 6px 12px;
            background: var(--arcade-dark);
            border: 2px solid var(--panel-border);
            border-radius: 6px 6px 0 0;
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-btn.active {
            background: var(--arcade-black);
            border-bottom-color: var(--arcade-black);
            color: var(--arcade-cyan);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .audio-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--panel-border);
        }

        #processingCanvas, #imageProcessingCanvas {
            display: none;
        }

        footer {
            text-align: center;
            padding: 20px;
            font-size: 10px;
            color: var(--text-dim);
        }

        footer a {
            color: var(--arcade-pink);
            text-decoration: none;
        }

        .info-box {
            background: rgba(255, 129, 53, 0.1);
            border: 1px solid var(--arcade-orange);
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 10px;
            color: var(--arcade-orange);
        }

        .info-box strong {
            color: var(--arcade-yellow);
        }

        .info-box.pink {
            background: rgba(255, 147, 196, 0.1);
            border-color: var(--arcade-pink);
            color: var(--arcade-pink);
        }

        .info-box.pink strong {
            color: #fff;
        }

        /* Image size info */
        .image-size-info {
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 8px;
            text-align: center;
        }

        .image-size-info strong {
            color: var(--arcade-cyan);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>MAKECODE ARCADE CONVERTER</h1>
            <p class="subtitle">Video, Audio, and Image ‚Üí MakeCode Sprites</p>
        </header>

        <!-- Mode Toggle -->
        <div class="mode-toggle">
            <button class="mode-btn active" data-mode="video">üé¨ Video/Audio</button>
            <button class="mode-btn" data-mode="image">üñºÔ∏è Image (Sprite)</button>
        </div>

        <!-- ==================== VIDEO/AUDIO MODE ==================== -->
        <div class="mode-content active" id="videoMode">
            <div class="main-grid">
                <!-- Left Panel: Input -->
                <div class="panel">
                    <h2 class="panel-title">Media Input</h2>
                    
                    <div class="upload-zone" id="uploadZone">
                        <span class="upload-icon">üé¨</span>
                        <p class="upload-text">Drop Video or Audio Here</p>
                        <p class="upload-hint">MP4, WebM, MOV, MP3, WAV</p>
                    </div>
                    <input type="file" id="videoInput" accept="video/*,audio/*,.mp3,.wav,.ogg,.m4a">

                    <div class="preview-container">
                        <video id="videoPreview" controls></video>
                        <audio id="audioPreview" controls style="display: none; width: 100%;"></audio>
                        <div class="preview-placeholder" id="previewPlaceholder">
                            No media loaded
                        </div>
                    </div>
                    
                    <div class="button-row" id="extractAudioRow" style="display: none; margin-bottom: 10px;">
                        <button class="btn btn-secondary" id="extractAudioBtn" style="flex: 1;">
                            üíæ Export as WAV
                        </button>
                        <button class="btn btn-primary" id="convertAudioOnlyBtn" style="flex: 1;">
                            üéµ Convert Audio Only
                        </button>
                    </div>

                    <div class="time-range-container" id="timeRangeContainer" style="display: none;">
                        <div class="time-range-bar">
                            <div class="time-range-selected" id="timeRangeSelected"></div>
                        </div>
                        <div class="time-range-labels">
                            <span id="timeRangeStart">0:00</span>
                            <span id="timeRangeInfo">Converting 0s - 10s</span>
                            <span id="timeRangeEnd">0:00</span>
                        </div>
                    </div>

                    <div class="controls-grid">
                        <div class="control-group">
                            <label>Start Time (s)</label>
                            <div style="display: flex; gap: 4px;">
                                <input type="number" id="startTime" value="0" min="0" step="0.1" style="flex: 1;">
                                <button class="btn btn-secondary" id="setStartBtn" title="Set to current time" style="padding: 8px 10px;">üìç</button>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Duration (s)</label>
                            <div style="display: flex; gap: 4px;">
                                <input type="number" id="duration" value="10" min="1" max="60" step="1" style="flex: 1;">
                                <button class="btn btn-secondary" id="seekToStartBtn" title="Seek to start" style="padding: 8px 10px;">‚èÆ</button>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Output Width</label>
                            <input type="number" id="outputWidth" value="80" min="16" max="160">
                        </div>
                        <div class="control-group">
                            <label>Output Height</label>
                            <input type="number" id="outputHeight" value="60" min="16" max="120">
                        </div>
                        <div class="control-group">
                            <label>Frame Rate</label>
                            <select id="frameRate">
                                <option value="5">5 fps</option>
                                <option value="10" selected>10 fps</option>
                                <option value="15">15 fps</option>
                                <option value="20">20 fps</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Max Frames</label>
                            <input type="number" id="maxFrames" value="100" min="1" max="500">
                        </div>
                        <div class="control-group">
                            <label>Dithering</label>
                            <select id="ditherMode">
                                <option value="floyd">Floyd-Steinberg</option>
                                <option value="ostromoukhov">Ostromoukhov</option>
                                <option value="ordered">Ordered (Bayer)</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Scale Mode</label>
                            <select id="scaleMode">
                                <option value="fill">Fill (crop)</option>
                                <option value="fit">Fit (letterbox)</option>
                                <option value="stretch">Stretch</option>
                            </select>
                        </div>
                    </div>

                    <div class="audio-section">
                        <div class="controls-grid">
                            <div class="control-group">
                                <label class="audio-label">Audio Period (ms)</label>
                                <input type="number" id="audioPeriod" value="50" min="20" max="200">
                            </div>
                            <div class="control-group">
                                <label class="audio-label">Audio Gain</label>
                                <input type="number" id="audioGain" value="1.0" min="0.1" max="5.0" step="0.1">
                            </div>
                        </div>

                        <div class="checkbox-group">
                            <input type="checkbox" id="extractAudio" checked>
                            <label for="extractAudio">Include audio (20-channel polyphonic)</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="videoOnly">
                            <label for="videoOnly">Video frames only (faster)</label>
                        </div>
                    </div>

                    <div class="button-row">
                        <button class="btn btn-primary" id="convertBtn" disabled>
                            ‚ö° Convert
                        </button>
                        <button class="btn btn-secondary" id="previewFrameBtn" disabled>
                            üëÅ Preview Frame
                        </button>
                        <button class="btn btn-secondary" id="skipAudioBtn" style="display: none;">
                            ‚è≠ Skip Audio
                        </button>
                    </div>

                    <div class="progress-container" id="progressContainer">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <p class="progress-text" id="progressText">Processing...</p>
                    </div>

                    <div class="status-message" id="statusMessage"></div>
                </div>

                <!-- Right Panel: Output -->
                <div class="panel audio-panel">
                    <h2 class="panel-title audio">Output</h2>

                    <label>Color Palette (16 colors)</label>
                    <div class="palette-preview" id="palettePreview">
                        <!-- Will be populated by JS -->
                    </div>

                    <label style="margin-top: 15px; display: block;">Frame Preview</label>
                    <div class="frame-preview-grid" id="framePreviewGrid">
                        <p style="grid-column: 1/-1; text-align: center; color: var(--text-dim); font-size: 10px;">
                            Frames will appear here after conversion
                        </p>
                    </div>

                    <div style="margin-top: 15px;">
                        <label class="audio-label">Audio Spectrogram</label>
                        <div class="spectrogram-container">
                            <canvas id="spectrogramCanvas"></canvas>
                        </div>
                        <label class="audio-label" style="margin-top: 10px; display: block;">Frequency Bands (20 channels)</label>
                        <div class="freq-buckets" id="freqBuckets">
                            <!-- Will be populated by JS -->
                        </div>
                    </div>

                    <div class="output-container">
                        <div class="output-tabs">
                            <button class="tab-btn active" data-tab="combined">Combined</button>
                            <button class="tab-btn" data-tab="video">Video</button>
                            <button class="tab-btn" data-tab="audio">Audio</button>
                        </div>

                        <div class="output-header">
                            <label>TypeScript Output</label>
                            <span class="output-stats" id="outputStats"></span>
                        </div>
                        
                        <div id="tab-combined" class="tab-content active">
                            <div class="output-code" id="outputCodeCombined">// Combined output will appear here</div>
                        </div>
                        <div id="tab-video" class="tab-content">
                            <div class="output-code" id="outputCodeVideo">// Video output will appear here</div>
                        </div>
                        <div id="tab-audio" class="tab-content">
                            <div class="output-code" id="outputCodeAudio">// Audio output will appear here</div>
                        </div>

                        <div class="button-row">
                            <button class="btn btn-copy" id="copyBtn" disabled>
                                üìã Copy
                            </button>
                            <button class="btn btn-secondary" id="downloadBtn" disabled>
                                üíæ Download
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== IMAGE MODE ==================== -->
        <div class="mode-content" id="imageMode">
            <div class="main-grid">
                <!-- Left Panel: Image Input -->
                <div class="panel image-panel">
                    <h2 class="panel-title image">Image Input</h2>
                    
                    <div class="upload-zone" id="imageUploadZone">
                        <span class="upload-icon">üñºÔ∏è</span>
                        <p class="upload-text">Drop Image Here</p>
                        <p class="upload-hint">PNG, JPG, GIF, WebP</p>
                    </div>
                    <input type="file" id="imageInput" accept="image/*">

                    <div class="image-preview-container" id="imagePreviewContainer">
                        <div class="preview-placeholder" id="imagePlaceholder">
                            No image loaded
                        </div>
                    </div>
                    <div class="image-size-info" id="imageSizeInfo"></div>

                    <div class="controls-grid">
                        <div class="control-group">
                            <label class="image-label">Output Width</label>
                            <input type="number" id="imageWidth" value="16" min="8" max="160">
                        </div>
                        <div class="control-group">
                            <label class="image-label">Output Height</label>
                            <input type="number" id="imageHeight" value="16" min="8" max="120">
                        </div>
                        <div class="control-group">
                            <label class="image-label">Dithering</label>
                            <select id="imageDitherMode">
                                <option value="floyd">Floyd-Steinberg</option>
                                <option value="ostromoukhov">Ostromoukhov</option>
                                <option value="ordered">Ordered (Bayer)</option>
                                <option value="none" selected>None</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="image-label">Scale Mode</label>
                            <select id="imageScaleMode">
                                <option value="fill">Fill (crop)</option>
                                <option value="fit" selected>Fit (letterbox)</option>
                                <option value="stretch">Stretch</option>
                            </select>
                        </div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="keepAspectRatio" checked>
                        <label for="keepAspectRatio">Lock aspect ratio when changing size</label>
                    </div>

                    <div class="info-box pink">
                        <strong>MakeCode Arcade Sprite Limits:</strong><br>
                        Standard sprites: 16√ó16 pixels<br>
                        Background images: up to 160√ó120 pixels
                    </div>

                    <div class="button-row">
                        <button class="btn btn-pink" id="convertImageBtn" disabled>
                            ‚ö° Convert to Sprite
                        </button>
                        <button class="btn btn-secondary" id="previewImageBtn" disabled>
                            üëÅ Preview
                        </button>
                    </div>

                    <div class="status-message" id="imageStatusMessage"></div>
                </div>

                <!-- Right Panel: Image Output -->
                <div class="panel image-panel">
                    <h2 class="panel-title image">Sprite Output</h2>

                    <label class="image-label">Color Palette (16 colors)</label>
                    <div class="palette-preview" id="imagePalettePreview">
                        <!-- Will be populated by JS -->
                    </div>

                    <label class="image-label" style="margin-top: 15px; display: block;">Preview</label>
                    <div class="image-preview-wrapper" id="spritePreviewArea">
                        <div class="image-preview-box">
                            <label class="image-label">Original (scaled)</label>
                            <canvas id="originalPreviewCanvas"></canvas>
                        </div>
                        <div class="image-preview-box">
                            <label class="image-label">Converted</label>
                            <canvas id="convertedPreviewCanvas"></canvas>
                        </div>
                    </div>

                    <div class="output-container">
                        <div class="output-header">
                            <label class="image-label">TypeScript Output</label>
                            <span class="output-stats" id="imageOutputStats"></span>
                        </div>
                        
                        <div class="output-code" id="imageSpriteCode">// Sprite code will appear here
// Example output:
let mySprite = sprites.create(img`
    . . . . . . . . 
    . . . . . . . . 
    . . . . . . . . 
    . . . . . . . . 
    . . . . . . . . 
    . . . . . . . . 
    . . . . . . . . 
    . . . . . . . . 
    `, SpriteKind.Player)</div>

                        <div class="button-row">
                            <button class="btn btn-copy" id="copyImageBtn" disabled>
                                üìã Copy Code
                            </button>
                            <button class="btn btn-secondary" id="copyRawSpriteBtn" disabled>
                                üìã Copy img`` Only
                            </button>
                            <button class="btn btn-secondary" id="downloadImageBtn" disabled>
                                üíæ Download
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            MakeCode Arcade Converter | Audio method based on <a href="https://github.com/HomeAssistantTycoon/Audio-to-MakeCode-Arcade" target="_blank">HomeAssistantTycoon's work</a>
        </footer>
    </div>

    <canvas id="processingCanvas"></canvas>
    <canvas id="imageProcessingCanvas"></canvas>

    <script>
        // MakeCode Arcade 16-color palette
        const MAKECODE_PALETTE = [
            { char: '.', name: 'Transparent', r: 0, g: 0, b: 0, a: 0 },
            { char: '1', name: 'White', r: 255, g: 255, b: 255, a: 255 },
            { char: '2', name: 'Red', r: 255, g: 33, b: 33, a: 255 },
            { char: '3', name: 'Pink', r: 255, g: 147, b: 196, a: 255 },
            { char: '4', name: 'Orange', r: 255, g: 129, b: 53, a: 255 },
            { char: '5', name: 'Yellow', r: 255, g: 246, b: 9, a: 255 },
            { char: '6', name: 'Teal', r: 36, g: 156, b: 163, a: 255 },
            { char: '7', name: 'Green', r: 120, g: 220, b: 82, a: 255 },
            { char: '8', name: 'Blue', r: 0, g: 63, b: 173, a: 255 },
            { char: '9', name: 'Light Blue', r: 135, g: 242, b: 255, a: 255 },
            { char: 'a', name: 'Purple', r: 142, g: 46, b: 196, a: 255 },
            { char: 'b', name: 'Light Purple', r: 164, g: 131, b: 159, a: 255 },
            { char: 'c', name: 'Dark Purple', r: 92, g: 64, b: 108, a: 255 },
            { char: 'd', name: 'Tan', r: 229, g: 205, b: 196, a: 255 },
            { char: 'e', name: 'Brown', r: 145, g: 70, b: 61, a: 255 },
            { char: 'f', name: 'Black', r: 0, g: 0, b: 0, a: 255 }
        ];

        // Frequency buckets matching the Python implementation
        const FREQUENCY_BUCKETS = [50, 159, 200, 252, 317, 400, 504, 635, 800, 1008,
                                   1270, 1600, 2016, 2504, 3200, 4032, 5080, 7000, 9000, 10240];

        const BAYER_4X4 = [
            [0, 8, 2, 10],
            [12, 4, 14, 6],
            [3, 11, 1, 9],
            [15, 7, 13, 5]
        ];

        // Ostromoukhov's variable coefficients table (SIGGRAPH 2001)
        // Each entry: [coef_right, coef_down_left, coef_down] for intensity level 0-255
        // Coefficients are scaled - divide by sum to normalize
        const OSTROMOUKHOV_COEFS = [
            [13,0,5],[13,0,5],[21,0,10],[7,0,4],[8,0,5],[47,3,28],[23,3,13],[15,3,8],
            [22,6,11],[43,15,20],[7,3,3],[501,224,211],[249,116,103],[165,80,67],[123,62,49],
            [489,256,191],[81,44,31],[483,272,181],[60,35,22],[53,32,19],[237,148,83],
            [471,304,161],[3,2,1],[481,314,185],[354,226,155],[1389,866,685],[227,138,125],
            [267,158,163],[327,188,220],[61,34,45],[627,338,505],[1227,638,1075],
            [20,10,19],[1937,1000,1767],[977,520,855],[657,360,551],[71,40,57],[2005,1160,1539],
            [337,200,247],[2039,1240,1425],[257,160,171],[691,440,437],[1045,680,627],
            [301,200,171],[177,120,95],[2141,1480,1083],[1079,760,513],[725,520,323],
            [137,100,57],[2209,1640,855],[53,40,19],[2243,1720,741],[565,440,171],
            [759,600,209],[1147,920,285],[2311,1880,513],[97,80,19],[335,280,57],
            [53,880,1],[2059,1720,69],[167,140,11],[1233,1040,39],[887,760,17],
            [2311,1960,53],[251,220,3],[2373,2080,47],[2391,2120,17],[2409,2160,1],
            [1,0,0],[2,1,0],[3,1,0],[4,1,0],[5,1,0],[6,1,0],[7,1,0],[8,1,0],[9,1,0],
            [10,1,0],[11,1,0],[12,1,0],[13,1,0],[14,1,0],[15,1,0],[16,1,0],[17,1,0],
            [18,1,0],[19,1,0],[20,1,0],[21,1,0],[22,1,0],[23,1,0],[24,1,0],[25,1,0],
            [26,1,0],[27,1,0],[28,1,0],[29,1,0],[30,1,0],[31,1,0],[32,1,0],[33,1,0],
            [34,1,0],[35,1,0],[36,1,0],[37,1,0],[38,1,0],[39,1,0],[40,1,0],[41,1,0],
            [42,1,0],[43,1,0],[44,1,0],[45,1,0],[46,1,0],[47,1,0],[48,1,0],[49,1,0],
            [50,1,0],[51,1,0],[52,1,0],[53,1,0],[54,1,0],[55,1,0],[56,1,0],[57,1,0],
            [58,1,0],[59,1,0],[60,1,0],[61,1,0],[62,1,0],[63,1,0],[64,1,0],[65,1,0],
            [66,1,0],[67,1,0],[68,1,0],[69,1,0],[70,1,0],[71,1,0],[72,1,0],[73,1,0],
            [74,1,0],[75,1,0],[76,1,0],[77,1,0],[78,1,0],[79,1,0],[80,1,0],[81,1,0],
            [82,1,0],[83,1,0],[84,1,0],[85,1,0],[86,1,0],[87,1,0],[88,1,0],[89,1,0],
            [90,1,0],[91,1,0],[92,1,0],[93,1,0],[94,1,0],[95,1,0],[96,1,0],[97,1,0],
            [98,1,0],[99,1,0],[100,1,0],[101,1,0],[102,1,0],[103,1,0],[104,1,0],
            [105,1,0],[106,1,0],[107,1,0],[108,1,0],[109,1,0],[110,1,0],[111,1,0],
            [112,1,0],[113,1,0],[114,1,0],[115,1,0],[116,1,0],[117,1,0],[118,1,0],
            [119,1,0],[120,1,0],[121,1,0],[122,1,0],[123,1,0],[124,1,0],[125,1,0],
            [126,1,0],[127,1,0],[128,1,0],[128,1,0],[127,1,0],[126,1,0],[125,1,0],
            [124,1,0],[123,1,0],[122,1,0],[121,1,0],[120,1,0],[119,1,0],[118,1,0],
            [117,1,0],[116,1,0],[115,1,0],[114,1,0],[113,1,0],[112,1,0],[111,1,0],
            [110,1,0],[109,1,0],[108,1,0],[107,1,0],[106,1,0],[105,1,0],[104,1,0],
            [103,1,0],[102,1,0],[101,1,0],[100,1,0],[99,1,0],[98,1,0],[97,1,0],
            [96,1,0],[95,1,0],[94,1,0],[93,1,0],[92,1,0],[91,1,0],[90,1,0],[89,1,0],
            [88,1,0],[87,1,0],[86,1,0],[85,1,0],[84,1,0],[83,1,0],[82,1,0],[81,1,0],
            [80,1,0],[79,1,0],[78,1,0],[77,1,0],[76,1,0],[75,1,0],[74,1,0],[73,1,0],
            [72,1,0],[71,1,0],[70,1,0],[69,1,0],[68,1,0],[67,1,0],[66,1,0],[65,1,0],
            [64,1,0],[63,1,0],[62,1,0],[61,1,0],[60,1,0],[59,1,0],[58,1,0],[57,1,0],
            [56,1,0],[55,1,0],[54,1,0],[53,1,0],[52,1,0],[51,1,0],[50,1,0],[49,1,0],
            [48,1,0],[47,1,0],[46,1,0],[45,1,0],[44,1,0],[43,1,0],[42,1,0],[41,1,0],
            [40,1,0],[39,1,0],[38,1,0],[37,1,0],[36,1,0],[35,1,0],[34,1,0],[33,1,0],
            [32,1,0],[31,1,0],[30,1,0],[29,1,0],[28,1,0],[27,1,0],[26,1,0],[25,1,0],
            [24,1,0],[23,1,0],[22,1,0],[21,1,0],[20,1,0],[19,1,0],[18,1,0],[17,1,0],
            [16,1,0],[15,1,0],[14,1,0],[13,1,0],[12,1,0],[11,1,0],[10,1,0],[9,1,0],
            [8,1,0],[7,1,0],[6,1,0],[5,1,0],[4,1,0],[3,1,0],[2,1,0],[1,1,0]
        ];

        // ==================== MODE SWITCHING ====================
        const modeBtns = document.querySelectorAll('.mode-btn');
        const modeContents = document.querySelectorAll('.mode-content');

        modeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                modeBtns.forEach(b => b.classList.remove('active'));
                modeContents.forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.mode + 'Mode').classList.add('active');
            });
        });

        // ==================== VIDEO/AUDIO MODE ELEMENTS ====================
        const uploadZone = document.getElementById('uploadZone');
        const videoInput = document.getElementById('videoInput');
        const videoPreview = document.getElementById('videoPreview');
        const audioPreview = document.getElementById('audioPreview');
        const previewPlaceholder = document.getElementById('previewPlaceholder');
        const extractAudioRow = document.getElementById('extractAudioRow');
        const extractAudioBtn = document.getElementById('extractAudioBtn');
        const convertAudioOnlyBtn = document.getElementById('convertAudioOnlyBtn');
        const timeRangeContainer = document.getElementById('timeRangeContainer');
        const timeRangeSelected = document.getElementById('timeRangeSelected');
        const timeRangeStart = document.getElementById('timeRangeStart');
        const timeRangeEnd = document.getElementById('timeRangeEnd');
        const timeRangeInfo = document.getElementById('timeRangeInfo');
        const convertBtn = document.getElementById('convertBtn');
        const previewFrameBtn = document.getElementById('previewFrameBtn');
        const copyBtn = document.getElementById('copyBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const statusMessage = document.getElementById('statusMessage');
        const framePreviewGrid = document.getElementById('framePreviewGrid');
        const palettePreview = document.getElementById('palettePreview');
        const freqBuckets = document.getElementById('freqBuckets');
        const spectrogramCanvas = document.getElementById('spectrogramCanvas');
        const spectrogramCtx = spectrogramCanvas.getContext('2d');
        const canvas = document.getElementById('processingCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        // Settings
        const startTime = document.getElementById('startTime');
        const duration = document.getElementById('duration');
        const outputWidth = document.getElementById('outputWidth');
        const outputHeight = document.getElementById('outputHeight');
        const frameRate = document.getElementById('frameRate');
        const maxFrames = document.getElementById('maxFrames');
        const ditherMode = document.getElementById('ditherMode');
        const scaleMode = document.getElementById('scaleMode');
        const audioPeriod = document.getElementById('audioPeriod');
        const audioGain = document.getElementById('audioGain');
        const extractAudio = document.getElementById('extractAudio');
        const videoOnly = document.getElementById('videoOnly');
        const skipAudioBtn = document.getElementById('skipAudioBtn');

        // Output
        const outputCodeCombined = document.getElementById('outputCodeCombined');
        const outputCodeVideo = document.getElementById('outputCodeVideo');
        const outputCodeAudio = document.getElementById('outputCodeAudio');
        const outputStats = document.getElementById('outputStats');

        // ==================== IMAGE MODE ELEMENTS ====================
        const imageUploadZone = document.getElementById('imageUploadZone');
        const imageInput = document.getElementById('imageInput');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePlaceholder = document.getElementById('imagePlaceholder');
        const imageSizeInfo = document.getElementById('imageSizeInfo');
        const imageWidth = document.getElementById('imageWidth');
        const imageHeight = document.getElementById('imageHeight');
        const imageDitherMode = document.getElementById('imageDitherMode');
        const imageScaleMode = document.getElementById('imageScaleMode');
        const keepAspectRatio = document.getElementById('keepAspectRatio');
        const convertImageBtn = document.getElementById('convertImageBtn');
        const previewImageBtn = document.getElementById('previewImageBtn');
        const imageStatusMessage = document.getElementById('imageStatusMessage');
        const imagePalettePreview = document.getElementById('imagePalettePreview');
        const originalPreviewCanvas = document.getElementById('originalPreviewCanvas');
        const convertedPreviewCanvas = document.getElementById('convertedPreviewCanvas');
        const imageSpriteCode = document.getElementById('imageSpriteCode');
        const imageOutputStats = document.getElementById('imageOutputStats');
        const copyImageBtn = document.getElementById('copyImageBtn');
        const copyRawSpriteBtn = document.getElementById('copyRawSpriteBtn');
        const downloadImageBtn = document.getElementById('downloadImageBtn');
        const imageCanvas = document.getElementById('imageProcessingCanvas');
        const imageCtx = imageCanvas.getContext('2d', { willReadFrequently: true });

        // State
        let convertedFrames = [];
        let audioBuffers = [];
        let generatedCode = { combined: '', video: '', audio: '' };
        let currentTab = 'combined';
        let isAudioOnly = false;
        let audioWorker = null;
        let spectrogramData = [];
        let skipAudioRequested = false;

        // Image state
        let loadedImage = null;
        let originalImageWidth = 0;
        let originalImageHeight = 0;
        let generatedSpriteCode = '';
        let generatedRawSprite = '';

        // ==================== SHARED UTILITY FUNCTIONS ====================

        function showStatus(message, type, elementId = 'statusMessage') {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.className = 'status-message ' + type;
            setTimeout(() => { el.className = 'status-message'; }, 5000);
        }

        // Color distance using weighted Euclidean
        function colorDistance(r1, g1, b1, r2, g2, b2) {
            const rMean = (r1 + r2) / 2;
            const dr = r1 - r2;
            const dg = g1 - g2;
            const db = b1 - b2;
            return Math.sqrt(
                (2 + rMean / 256) * dr * dr +
                4 * dg * dg +
                (2 + (255 - rMean) / 256) * db * db
            );
        }

        function findNearestColor(r, g, b, a) {
            if (a < 128) return MAKECODE_PALETTE[0];
            let minDist = Infinity;
            let nearest = MAKECODE_PALETTE[15];
            for (let i = 1; i < MAKECODE_PALETTE.length; i++) {
                const color = MAKECODE_PALETTE[i];
                const dist = colorDistance(r, g, b, color.r, color.g, color.b);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = color;
                }
            }
            return nearest;
        }

        // Dithering functions
        function applyFloydSteinberg(imageData, width, height) {
            const data = imageData.data;
            const errors = new Float32Array(width * height * 3);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const ei = (y * width + x) * 3;

                    let r = Math.max(0, Math.min(255, data[i] + errors[ei]));
                    let g = Math.max(0, Math.min(255, data[i + 1] + errors[ei + 1]));
                    let b = Math.max(0, Math.min(255, data[i + 2] + errors[ei + 2]));
                    const a = data[i + 3];

                    const nearest = findNearestColor(r, g, b, a);
                    const errR = r - nearest.r;
                    const errG = g - nearest.g;
                    const errB = b - nearest.b;

                    const distribute = (dx, dy, factor) => {
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const ni = (ny * width + nx) * 3;
                            errors[ni] += errR * factor;
                            errors[ni + 1] += errG * factor;
                            errors[ni + 2] += errB * factor;
                        }
                    };

                    distribute(1, 0, 7/16);
                    distribute(-1, 1, 3/16);
                    distribute(0, 1, 5/16);
                    distribute(1, 1, 1/16);

                    data[i] = nearest.r;
                    data[i + 1] = nearest.g;
                    data[i + 2] = nearest.b;
                }
            }
            return imageData;
        }

        function applyOrderedDither(imageData, width, height) {
            const data = imageData.data;
            const threshold = 4;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const bayerValue = BAYER_4X4[y % 4][x % 4];
                    const offset = (bayerValue - 7.5) * threshold;

                    const r = Math.max(0, Math.min(255, data[i] + offset));
                    const g = Math.max(0, Math.min(255, data[i + 1] + offset));
                    const b = Math.max(0, Math.min(255, data[i + 2] + offset));
                    const a = data[i + 3];

                    const nearest = findNearestColor(r, g, b, a);
                    data[i] = nearest.r;
                    data[i + 1] = nearest.g;
                    data[i + 2] = nearest.b;
                }
            }
            return imageData;
        }

        function applyOstromoukhov(imageData, width, height) {
            const data = imageData.data;
            const errors = new Float32Array(width * height * 3);

            for (let y = 0; y < height; y++) {
                // Serpentine scanning: alternate direction each row
                const leftToRight = (y % 2 === 0);
                const startX = leftToRight ? 0 : width - 1;
                const endX = leftToRight ? width : -1;
                const stepX = leftToRight ? 1 : -1;

                for (let x = startX; x !== endX; x += stepX) {
                    const i = (y * width + x) * 4;
                    const ei = (y * width + x) * 3;

                    let r = Math.max(0, Math.min(255, data[i] + errors[ei]));
                    let g = Math.max(0, Math.min(255, data[i + 1] + errors[ei + 1]));
                    let b = Math.max(0, Math.min(255, data[i + 2] + errors[ei + 2]));
                    const a = data[i + 3];

                    // Get intensity for coefficient lookup (use luminance)
                    const intensity = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                    const coefs = OSTROMOUKHOV_COEFS[Math.min(255, Math.max(0, intensity))];
                    const sum = coefs[0] + coefs[1] + coefs[2];

                    const nearest = findNearestColor(r, g, b, a);
                    const errR = r - nearest.r;
                    const errG = g - nearest.g;
                    const errB = b - nearest.b;

                    // Distribute error with variable coefficients
                    // Right (or left if going right-to-left)
                    const nx1 = x + stepX;
                    if (nx1 >= 0 && nx1 < width) {
                        const ni = (y * width + nx1) * 3;
                        const factor = coefs[0] / sum;
                        errors[ni] += errR * factor;
                        errors[ni + 1] += errG * factor;
                        errors[ni + 2] += errB * factor;
                    }

                    // Down-opposite (down-left if LTR, down-right if RTL)
                    if (y + 1 < height) {
                        const nx2 = x - stepX;
                        if (nx2 >= 0 && nx2 < width) {
                            const ni = ((y + 1) * width + nx2) * 3;
                            const factor = coefs[1] / sum;
                            errors[ni] += errR * factor;
                            errors[ni + 1] += errG * factor;
                            errors[ni + 2] += errB * factor;
                        }

                        // Down
                        const ni = ((y + 1) * width + x) * 3;
                        const factor = coefs[2] / sum;
                        errors[ni] += errR * factor;
                        errors[ni + 1] += errG * factor;
                        errors[ni + 2] += errB * factor;
                    }

                    data[i] = nearest.r;
                    data[i + 1] = nearest.g;
                    data[i + 2] = nearest.b;
                }
            }
            return imageData;
        }

        function imageDataToMakeCode(imageData, width, height) {
            const data = imageData.data;
            let result = '';
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const nearest = findNearestColor(data[i], data[i+1], data[i+2], data[i+3]);
                    result += nearest.char;
                    if (x < width - 1) result += ' ';
                }
                result += '\n';
            }
            return result.trim();
        }

        // Initialize palette preview
        function initPalettePreview(containerId = 'palettePreview') {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            MAKECODE_PALETTE.forEach((color) => {
                const div = document.createElement('div');
                div.className = 'palette-color';
                div.style.backgroundColor = color.a === 0 
                    ? 'repeating-conic-gradient(#666 0% 25%, #999 0% 50%) 50% / 6px 6px'
                    : `rgb(${color.r}, ${color.g}, ${color.b})`;
                div.dataset.char = color.char;
                div.title = `${color.char}: ${color.name}`;
                container.appendChild(div);
            });
        }

        // ==================== IMAGE MODE FUNCTIONS ====================

        // Handle image upload
        imageUploadZone.addEventListener('click', () => imageInput.click());
        imageUploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            imageUploadZone.classList.add('dragover');
        });
        imageUploadZone.addEventListener('dragleave', () => {
            imageUploadZone.classList.remove('dragover');
        });
        imageUploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            imageUploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImageFile(file);
            }
        });

        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImageFile(file);
        });

        function loadImageFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    loadedImage = img;
                    originalImageWidth = img.width;
                    originalImageHeight = img.height;

                    // Show preview
                    imagePreviewContainer.innerHTML = '';
                    const previewImg = document.createElement('img');
                    previewImg.src = e.target.result;
                    previewImg.style.maxWidth = '100%';
                    previewImg.style.maxHeight = '300px';
                    imagePreviewContainer.appendChild(previewImg);

                    imageSizeInfo.innerHTML = `Original size: <strong>${img.width}√ó${img.height}</strong> pixels`;

                    // Enable buttons
                    convertImageBtn.disabled = false;
                    previewImageBtn.disabled = false;

                    showStatus(`Image loaded: ${file.name}`, 'success', 'imageStatusMessage');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Aspect ratio locking
        let lastChangedDimension = 'width';
        imageWidth.addEventListener('input', () => {
            if (keepAspectRatio.checked && loadedImage) {
                const aspect = originalImageWidth / originalImageHeight;
                imageHeight.value = Math.round(parseInt(imageWidth.value) / aspect);
            }
            lastChangedDimension = 'width';
        });

        imageHeight.addEventListener('input', () => {
            if (keepAspectRatio.checked && loadedImage) {
                const aspect = originalImageWidth / originalImageHeight;
                imageWidth.value = Math.round(parseInt(imageHeight.value) * aspect);
            }
            lastChangedDimension = 'height';
        });

        // Process image
        function processImage(img, targetWidth, targetHeight, dither, scale) {
            imageCanvas.width = targetWidth;
            imageCanvas.height = targetHeight;
            imageCtx.clearRect(0, 0, targetWidth, targetHeight);

            // Fill with transparent
            imageCtx.fillStyle = 'rgba(0,0,0,0)';
            imageCtx.fillRect(0, 0, targetWidth, targetHeight);

            const imgAspect = img.width / img.height;
            const targetAspect = targetWidth / targetHeight;
            let sx = 0, sy = 0, sw = img.width, sh = img.height;
            let dx = 0, dy = 0, dw = targetWidth, dh = targetHeight;

            if (scale === 'fit') {
                if (imgAspect > targetAspect) {
                    dh = targetWidth / imgAspect;
                    dy = (targetHeight - dh) / 2;
                } else {
                    dw = targetHeight * imgAspect;
                    dx = (targetWidth - dw) / 2;
                }
            } else if (scale === 'fill') {
                if (imgAspect > targetAspect) {
                    sw = img.height * targetAspect;
                    sx = (img.width - sw) / 2;
                } else {
                    sh = img.width / targetAspect;
                    sy = (img.height - sh) / 2;
                }
            }

            imageCtx.imageSmoothingEnabled = true;
            imageCtx.imageSmoothingQuality = 'high';
            imageCtx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);

            let imageData = imageCtx.getImageData(0, 0, targetWidth, targetHeight);

            if (dither === 'floyd') {
                imageData = applyFloydSteinberg(imageData, targetWidth, targetHeight);
            } else if (dither === 'ostromoukhov') {
                imageData = applyOstromoukhov(imageData, targetWidth, targetHeight);
            } else if (dither === 'ordered') {
                imageData = applyOrderedDither(imageData, targetWidth, targetHeight);
            } else {
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const nearest = findNearestColor(data[i], data[i+1], data[i+2], data[i+3]);
                    data[i] = nearest.r;
                    data[i + 1] = nearest.g;
                    data[i + 2] = nearest.b;
                }
            }

            imageCtx.putImageData(imageData, 0, 0);

            return {
                imageData,
                makeCodeString: imageDataToMakeCode(imageData, targetWidth, targetHeight),
                dataUrl: imageCanvas.toDataURL()
            };
        }

        // Preview button
        previewImageBtn.addEventListener('click', () => {
            if (!loadedImage) return;

            const width = parseInt(imageWidth.value);
            const height = parseInt(imageHeight.value);

            // Draw original (scaled down to preview)
            const previewScale = Math.min(160 / width, 120 / height, 4);
            originalPreviewCanvas.width = width * previewScale;
            originalPreviewCanvas.height = height * previewScale;
            const origCtx = originalPreviewCanvas.getContext('2d');
            origCtx.imageSmoothingEnabled = false;
            
            // Draw scaled version of original
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(loadedImage, 0, 0, width, height);
            origCtx.drawImage(tempCanvas, 0, 0, originalPreviewCanvas.width, originalPreviewCanvas.height);

            // Process and draw converted
            const result = processImage(loadedImage, width, height, imageDitherMode.value, imageScaleMode.value);
            convertedPreviewCanvas.width = width * previewScale;
            convertedPreviewCanvas.height = height * previewScale;
            const convCtx = convertedPreviewCanvas.getContext('2d');
            convCtx.imageSmoothingEnabled = false;
            const convImg = new Image();
            convImg.onload = () => {
                convCtx.drawImage(convImg, 0, 0, convertedPreviewCanvas.width, convertedPreviewCanvas.height);
            };
            convImg.src = result.dataUrl;

            showStatus('Preview generated', 'info', 'imageStatusMessage');
        });

        // Convert button
        convertImageBtn.addEventListener('click', () => {
            if (!loadedImage) return;

            const width = parseInt(imageWidth.value);
            const height = parseInt(imageHeight.value);

            const result = processImage(loadedImage, width, height, imageDitherMode.value, imageScaleMode.value);

            // Generate sprite code
            generatedRawSprite = `img\`\n    ${result.makeCodeString.split('\n').join('\n    ')}\n    \``;
            generatedSpriteCode = `let mySprite = sprites.create(${generatedRawSprite}, SpriteKind.Player)`;

            imageSpriteCode.textContent = generatedSpriteCode;

            // Update preview
            const previewScale = Math.min(160 / width, 120 / height, 4);
            
            originalPreviewCanvas.width = width * previewScale;
            originalPreviewCanvas.height = height * previewScale;
            const origCtx = originalPreviewCanvas.getContext('2d');
            origCtx.imageSmoothingEnabled = false;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(loadedImage, 0, 0, width, height);
            origCtx.drawImage(tempCanvas, 0, 0, originalPreviewCanvas.width, originalPreviewCanvas.height);

            convertedPreviewCanvas.width = width * previewScale;
            convertedPreviewCanvas.height = height * previewScale;
            const convCtx = convertedPreviewCanvas.getContext('2d');
            convCtx.imageSmoothingEnabled = false;
            const convImg = new Image();
            convImg.onload = () => {
                convCtx.drawImage(convImg, 0, 0, convertedPreviewCanvas.width, convertedPreviewCanvas.height);
            };
            convImg.src = result.dataUrl;

            // Stats
            const codeSize = new Blob([generatedSpriteCode]).size;
            imageOutputStats.textContent = `${width}√ó${height} pixels | ${(codeSize / 1024).toFixed(1)} KB`;

            // Enable buttons
            copyImageBtn.disabled = false;
            copyRawSpriteBtn.disabled = false;
            downloadImageBtn.disabled = false;

            showStatus(`Converted! ${width}√ó${height} sprite ready`, 'success', 'imageStatusMessage');
        });

        // Copy buttons
        copyImageBtn.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(generatedSpriteCode);
                showStatus('Full sprite code copied!', 'success', 'imageStatusMessage');
            } catch (err) {
                showStatus('Failed to copy', 'error', 'imageStatusMessage');
            }
        });

        copyRawSpriteBtn.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(generatedRawSprite);
                showStatus('img`` copied!', 'success', 'imageStatusMessage');
            } catch (err) {
                showStatus('Failed to copy', 'error', 'imageStatusMessage');
            }
        });

        downloadImageBtn.addEventListener('click', () => {
            const blob = new Blob([generatedSpriteCode], { type: 'text/typescript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'makecode-sprite.ts';
            a.click();
            URL.revokeObjectURL(url);
            showStatus('Downloaded makecode-sprite.ts', 'success', 'imageStatusMessage');
        });

        // ==================== VIDEO/AUDIO MODE FUNCTIONS ====================
        // (Keep all the original video/audio functionality below)

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function getMediaElement() {
            return isAudioOnly ? audioPreview : videoPreview;
        }

        function updateTimeRangeDisplay() {
            const media = getMediaElement();
            if (!media.duration) return;
            
            const totalDuration = media.duration;
            const clipStart = Math.min(parseFloat(startTime.value) || 0, totalDuration);
            const clipDur = parseFloat(duration.value) || 10;
            const clipEnd = Math.min(clipStart + clipDur, totalDuration);
            const actualDur = clipEnd - clipStart;
            
            const leftPercent = (clipStart / totalDuration) * 100;
            const widthPercent = (actualDur / totalDuration) * 100;
            timeRangeSelected.style.left = `${leftPercent}%`;
            timeRangeSelected.style.width = `${widthPercent}%`;
            
            timeRangeStart.textContent = formatTime(0);
            timeRangeEnd.textContent = formatTime(totalDuration);
            timeRangeInfo.textContent = `Converting ${formatTime(clipStart)} - ${formatTime(clipEnd)} (${actualDur.toFixed(1)}s)`;
            
            timeRangeContainer.style.display = 'block';
        }

        startTime.addEventListener('input', updateTimeRangeDisplay);
        duration.addEventListener('input', updateTimeRangeDisplay);
        
        const seekToStartBtn = document.getElementById('seekToStartBtn');
        const setStartBtn = document.getElementById('setStartBtn');
        
        seekToStartBtn.addEventListener('click', () => {
            const start = parseFloat(startTime.value) || 0;
            getMediaElement().currentTime = start;
        });
        
        setStartBtn.addEventListener('click', () => {
            const media = getMediaElement();
            startTime.value = media.currentTime.toFixed(1);
            updateTimeRangeDisplay();
            showStatus(`Start time set to ${formatTime(media.currentTime)}`, 'info');
        });

        function processFrame(video, targetWidth, targetHeight, dither, scale) {
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            ctx.clearRect(0, 0, targetWidth, targetHeight);

            const videoAspect = video.videoWidth / video.videoHeight;
            const targetAspect = targetWidth / targetHeight;
            let sx = 0, sy = 0, sw = video.videoWidth, sh = video.videoHeight;
            let dx = 0, dy = 0, dw = targetWidth, dh = targetHeight;

            if (scale === 'fit') {
                if (videoAspect > targetAspect) {
                    dh = targetWidth / videoAspect;
                    dy = (targetHeight - dh) / 2;
                } else {
                    dw = targetHeight * videoAspect;
                    dx = (targetWidth - dw) / 2;
                }
            } else if (scale === 'fill') {
                if (videoAspect > targetAspect) {
                    sw = video.videoHeight * targetAspect;
                    sx = (video.videoWidth - sw) / 2;
                } else {
                    sh = video.videoWidth / targetAspect;
                    sy = (video.videoHeight - sh) / 2;
                }
            }

            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);

            let imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);

            if (dither === 'floyd') {
                imageData = applyFloydSteinberg(imageData, targetWidth, targetHeight);
            } else if (dither === 'ostromoukhov') {
                imageData = applyOstromoukhov(imageData, targetWidth, targetHeight);
            } else if (dither === 'ordered') {
                imageData = applyOrderedDither(imageData, targetWidth, targetHeight);
            } else {
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const nearest = findNearestColor(data[i], data[i+1], data[i+2], data[i+3]);
                    data[i] = nearest.r;
                    data[i + 1] = nearest.g;
                    data[i + 2] = nearest.b;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            return {
                imageData,
                makeCodeString: imageDataToMakeCode(imageData, targetWidth, targetHeight),
                dataUrl: canvas.toDataURL()
            };
        }

        // Video upload handlers
        uploadZone.addEventListener('click', () => videoInput.click());
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });
        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleMediaFile(file);
        });

        videoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleMediaFile(file);
        });

        function handleMediaFile(file) {
            const url = URL.createObjectURL(file);
            isAudioOnly = file.type.startsWith('audio/');
            
            if (isAudioOnly) {
                videoPreview.style.display = 'none';
                audioPreview.style.display = 'block';
                audioPreview.src = url;
                previewPlaceholder.style.display = 'none';
                
                audioPreview.onloadedmetadata = () => {
                    convertBtn.disabled = false;
                    previewFrameBtn.disabled = true;
                    extractAudioRow.style.display = 'flex';
                    updateTimeRangeDisplay();
                    showStatus(`Audio loaded: ${file.name} (${formatTime(audioPreview.duration)})`, 'success');
                };
            } else {
                audioPreview.style.display = 'none';
                videoPreview.style.display = 'block';
                videoPreview.src = url;
                previewPlaceholder.style.display = 'none';
                
                videoPreview.onloadedmetadata = () => {
                    convertBtn.disabled = false;
                    previewFrameBtn.disabled = false;
                    extractAudioRow.style.display = 'flex';
                    updateTimeRangeDisplay();
                    showStatus(`Video loaded: ${file.name} (${formatTime(videoPreview.duration)})`, 'success');
                };
            }
        }

        // Generate video code
        function generateVideoCode(frames, width, height) {
            let code = `// Video frames: ${frames.length} @ ${width}x${height}\n`;
            code += `let frames: Image[] = [\n`;
            
            frames.forEach((frame, i) => {
                code += `    img\`\n`;
                const lines = frame.makeCodeString.split('\n');
                lines.forEach(line => {
                    code += `        ${line}\n`;
                });
                code += `    \`${i < frames.length - 1 ? ',' : ''}\n`;
            });
            
            code += `]\n`;
            return code;
        }

        // Generate audio code (placeholder - full implementation would be in the worker)
        function generateAudioCode(buffers, period) {
            if (buffers.length === 0) return '// No audio data';
            
            let code = `// Audio: ${buffers.length} frequency channels @ ${period}ms period\n`;
            code += `// Polyphonic playback using music.playInstructions\n\n`;
            
            buffers.forEach((buf, i) => {
                if (buf && buf.length > 0) {
                    code += `const ch${i} = hex\`${buf}\`\n`;
                }
            });
            
            code += `\n// Play all channels simultaneously\n`;
            code += `music.playInstructions(${period}, ch0)\n`;
            
            return code;
        }

        // Generate combined code
        function generateCombinedCode(frames, audioBuffers, width, height, fps, period) {
            let code = generateVideoCode(frames, width, height);
            code += '\n';
            
            if (audioBuffers.length > 0) {
                code += generateAudioCode(audioBuffers, period);
                code += '\n';
            }
            
            code += `// Synchronized playback\n`;
            code += `let frameIndex = 0\n`;
            code += `game.onUpdateInterval(${Math.round(1000/fps)}, function() {\n`;
            code += `    scene.setBackgroundImage(frames[frameIndex])\n`;
            code += `    frameIndex = (frameIndex + 1) % frames.length\n`;
            code += `})\n`;
            
            return code;
        }

        // Preview frame button
        previewFrameBtn.addEventListener('click', () => {
            if (isAudioOnly) return;
            
            const width = parseInt(outputWidth.value);
            const height = parseInt(outputHeight.value);
            
            const result = processFrame(videoPreview, width, height, ditherMode.value, scaleMode.value);
            
            framePreviewGrid.innerHTML = '';
            const thumb = document.createElement('img');
            thumb.src = result.dataUrl;
            thumb.className = 'frame-thumb';
            thumb.style.width = '100%';
            thumb.style.maxWidth = '200px';
            framePreviewGrid.appendChild(thumb);
            
            showStatus(`Preview: ${width}x${height}`, 'info');
        });

        // Initialize frequency buckets
        function initFreqBuckets() {
            freqBuckets.innerHTML = '';
            for (let i = 0; i < FREQUENCY_BUCKETS.length; i++) {
                const div = document.createElement('div');
                div.className = 'freq-bucket';
                div.style.height = '2px';
                div.title = `${i > 0 ? FREQUENCY_BUCKETS[i-1] : 0}-${FREQUENCY_BUCKETS[i]} Hz`;
                freqBuckets.appendChild(div);
            }
        }

        function updateFreqBuckets(amplitudes) {
            const buckets = freqBuckets.children;
            const maxAmp = Math.max(...amplitudes, 0.001);
            for (let i = 0; i < buckets.length && i < amplitudes.length; i++) {
                const height = Math.max(2, (amplitudes[i] / maxAmp) * 50);
                buckets[i].style.height = height + 'px';
            }
        }

        // Draw spectrogram
        function drawSpectrogram(data) {
            if (!data || data.length === 0) return;
            
            const width = spectrogramCanvas.offsetWidth || 400;
            const height = 100;
            spectrogramCanvas.width = width;
            spectrogramCanvas.height = height;
            
            const ctx = spectrogramCtx;
            ctx.fillStyle = '#0d0d0d';
            ctx.fillRect(0, 0, width, height);
            
            // Simple visualization
            const barWidth = Math.max(1, width / data.length);
            data.forEach((frame, i) => {
                const x = i * barWidth;
                let maxVal = 0;
                for (let j = 0; j < frame.length; j++) {
                    if (frame[j] > maxVal) maxVal = frame[j];
                }
                const barHeight = (maxVal / 1024) * height;
                const hue = 30 + (maxVal / 1024) * 30;
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.fillRect(x, height - barHeight, barWidth, barHeight);
            });
        }

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
                currentTab = btn.dataset.tab;
            });
        });

        // Main convert button (simplified - full audio worker code omitted for brevity)
        convertBtn.addEventListener('click', async () => {
            if (isAudioOnly) {
                showStatus('Audio-only conversion - use the Audio Only button', 'info');
                return;
            }
            
            convertBtn.disabled = true;
            previewFrameBtn.disabled = true;
            progressContainer.classList.add('active');
            progressFill.style.width = '0%';
            
            const conversionStartTime = performance.now();

            try {
                const fps = parseInt(frameRate.value);
                const maxCount = parseInt(maxFrames.value);
                const width = parseInt(outputWidth.value);
                const height = parseInt(outputHeight.value);

                const clipStart = parseFloat(startTime.value) || 0;
                const clipDuration = parseFloat(duration.value) || 10;
                const clipEnd = Math.min(clipStart + clipDuration, videoPreview.duration);
                const actualDuration = clipEnd - clipStart;

                // Extract video frames
                convertedFrames = [];
                framePreviewGrid.innerHTML = '';
                const frameInterval = 1 / fps;
                const totalFrames = Math.min(Math.floor(actualDuration * fps), maxCount);

                for (let i = 0; i < totalFrames; i++) {
                    const frameTime = clipStart + (i * frameInterval);
                    if (frameTime >= clipEnd) break;
                    
                    videoPreview.currentTime = frameTime;
                    await new Promise(resolve => { videoPreview.onseeked = resolve; });
                    await new Promise(resolve => setTimeout(resolve, 50));

                    const result = processFrame(videoPreview, width, height, ditherMode.value, scaleMode.value);
                    convertedFrames.push(result);

                    const thumb = document.createElement('img');
                    thumb.src = result.dataUrl;
                    thumb.className = 'frame-thumb';
                    framePreviewGrid.appendChild(thumb);

                    const progress = ((i + 1) / totalFrames) * 100;
                    progressFill.style.width = `${progress}%`;
                    progressText.textContent = `Extracting frame ${i + 1}/${totalFrames} (${frameTime.toFixed(1)}s)...`;
                }

                progressFill.style.width = '100%';

                generatedCode.video = generateVideoCode(convertedFrames, width, height);
                generatedCode.audio = '// Audio extraction not included in this simplified version';
                generatedCode.combined = generatedCode.video + '\n\n// Animation loop\nwhile (true) {\n    for (let frame of frames) {\n        scene.setBackgroundImage(frame)\n        pause(100)\n    }\n}\n';

                outputCodeCombined.textContent = generatedCode.combined;
                outputCodeVideo.textContent = generatedCode.video;
                outputCodeAudio.textContent = generatedCode.audio;

                const codeSize = new Blob([generatedCode.combined]).size;
                outputStats.textContent = `${convertedFrames.length} frames | ${(codeSize / 1024).toFixed(1)} KB`;

                copyBtn.disabled = false;
                downloadBtn.disabled = false;
                
                const totalElapsed = ((performance.now() - conversionStartTime) / 1000).toFixed(1);
                showStatus(`Done in ${totalElapsed}s! ${convertedFrames.length} frames extracted`, 'success');

            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error(error);
            }

            progressContainer.classList.remove('active');
            convertBtn.disabled = false;
            previewFrameBtn.disabled = isAudioOnly;
        });

        copyBtn.addEventListener('click', async () => {
            const code = generatedCode[currentTab] || generatedCode.combined;
            try {
                await navigator.clipboard.writeText(code);
                showStatus('Code copied to clipboard!', 'success');
            } catch (error) {
                showStatus('Failed to copy', 'error');
            }
        });

        downloadBtn.addEventListener('click', () => {
            const code = generatedCode[currentTab] || generatedCode.combined;
            const blob = new Blob([code], { type: 'text/typescript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `makecode-${currentTab}.ts`;
            a.click();
            URL.revokeObjectURL(url);
            showStatus(`Downloaded makecode-${currentTab}.ts`, 'success');
        });

        // Initialize
        initPalettePreview('palettePreview');
        initPalettePreview('imagePalettePreview');
        initFreqBuckets();
        
        window.addEventListener('resize', () => {
            if (spectrogramData.length > 0) {
                drawSpectrogram(spectrogramData);
            }
        });
    </script>
</body>
</html>
